
const makeAbsolute = require('./makeAbsolute')
const path = require('path')
const findPackage = require('find-package')
const fs = require('fs')

const PATTERN = require('./versionTools').PATTERN
const createContent = require('./versionTools').createContent

exports.check = (targetPath, opts, callback) => {
  // Check if a version file can be generated.
  //
  // Parameters
  //   targetPath
  //     relative or absolute filepath to version file.
  //   opts
  //     optional options object. See exports.dry docs for details.
  //   callback
  //     function (err, doesExist, isByGenversion, isUpToDate)
  //       err
  //         non-null on file system error
  //       doesExist
  //         boolean, if the version file exists
  //       isByGenversion
  //         boolean, true if file exists and is generated by genversion.
  //         The check is done by comparing the SIGNATURE on the first line.
  //       isUpToDate
  //         boolean, true if contents of the file are exactly as
  //         freshly generated.
  //
  if (typeof callback !== 'function') {
    if (typeof opts !== 'function') {
      throw new Error('Unexpected callback argument')
    } else {
      callback = opts
      opts = {}
    }
  }

  exports.dry(targetPath, opts, (err, result) => {
    if (err) {
      return callback(err)
    }

    const absTarget = result.absoluteTargetPath
    const referenceContent = result.generatedContent

    fs.readFile(absTarget, 'utf8', (errf, fileContent) => {
      if (errf) {
        if (errf.code === 'ENOENT') {
          // OK, file does not exist.
          return callback(null, false, false, false)
        }
        // Real error.
        return callback(errf, false, false, false)
      }

      // Get first line to test if we can touch the file.
      // We should not touch the file if it not created by genversion.
      const linebreak = fileContent.indexOf('\n')
      let firstline = fileContent.substring(0, linebreak)
      // In the case fileContent is a single line
      if (linebreak < 0) {
        firstline = fileContent
      }
      // Find the signature pattern in the first line.
      if (!firstline.match(PATTERN)) {
        // The file exists but is not created by genversion
        return callback(null, true, false, false)
      }

      // Issue axelpale/genversion#15
      // Remove all the CR characters inserted by git on clone/checkout
      // when git configuration has core.autocrlf=true
      while (fileContent.indexOf('\r') >= 0) {
        fileContent = fileContent.replace(/\r/, '')
      }

      if (fileContent !== referenceContent) {
        // The file is created by genversion but has outdated content
        return callback(null, true, true, false)
      }

      // OK, the existing file was generated by genversion and is up to date.
      return callback(null, true, true, true)
    })
  })
}

exports.dry = (targetPath, opts, callback) => {
  // Dry-run version submodule generation.
  // Works as a preprocessing step for exports.generate
  //
  // Parameters:
  //   targetPath
  //     string. absolute or relative path
  //   opts
  //     optional object with optional properties
  //       source
  //         file path string. A path to package.json
  //       useSemicolon
  //         boolean. Set true to use semicolons in generated code
  //       useDoubleQuotes
  //         boolean. Set true to use double quotes in generated code
  //         instead of single quotes.
  //       useEs6Syntax
  //         boolean. Set true to use ES6 export syntax
  //       useStrict:
  //         boolean. Add the 'use strict' header
  //   callback
  //     function (err, dryRunResult)
  //       err
  //         null if generated successfully
  //         non-null if no package.json found or version in it is invalid
  //       dryRunResult, object with props:
  //         absoluteTargetPath
  //           absolute path of the target version submodule
  //         completeOptions
  //           validated and filled options object
  //         version
  //           new version string, undefined on error
  //         generatedContent
  //           string, contents for the new version submodule
  //
  if (typeof targetPath !== 'string') {
    throw new Error('Unexpected targetPath argument')
  }

  if (typeof callback !== 'function') {
    if (typeof opts !== 'function') {
      throw new Error('Unexpected callback argument')
    } else {
      callback = opts
      opts = {}
    }
  }

  if (typeof opts !== 'object') {
    throw new Error('Unexpected opts argument')
  }

  if (typeof opts.useSemicolon !== 'boolean') {
    opts.useSemicolon = false // default
  }

  if (typeof opts.useDoubleQuotes !== 'boolean') {
    opts.useDoubleQuotes = false // default
  }

  if (typeof opts.useEs6Syntax !== 'boolean') {
    opts.useEs6Syntax = false // default
  }

  if (typeof opts.useStrict !== 'boolean') {
    opts.useStrict = false // default
  }

  if (typeof opts.source !== 'string') {
    opts.source = targetPath // default
  }

  const absTarget = makeAbsolute(targetPath)
  const absSource = makeAbsolute(opts.source)

  // Find closest package.json from the target towards filesystem root
  const pjson = findPackage(absSource)

  // findPackage returns null if not found
  if (pjson === null) {
    const err = new Error('No package.json found along path ' + absSource)
    return callback(err)
  }

  // Get version property
  const version = pjson.version

  // Ensure version is a string
  if (typeof version !== 'string') {
    const err = new Error('Invalid version in package.json: ' + version)
    return callback(err)
  }

  const content = createContent(version, opts)

  return callback(null, {
    absoluteTargetPath: absTarget,
    completeOptions: opts,
    version: version,
    generatedContent: content
  })
}

exports.generate = (targetPath, opts, callback) => {
  // Generate version submodule file to targetPath with utf-8 encoding.
  //
  // Parameters:
  //   targetPath
  //     string. absolute or relative path
  //   opts
  //     optional object with optional properties
  //       source
  //         file path string. A path to package.json
  //       useSemicolon
  //         boolean. Set true to use semicolons in generated code
  //       useDoubleQuotes
  //         boolean. Set true to use double quotes in generated code
  //         instead of single quotes.
  //       useEs6Syntax
  //         boolean. Set true to use ES6 export syntax
  //       useStrict:
  //         boolean. Add the 'use strict' header
  //   callback
  //     function (err, version)
  //       err
  //         null if generated successfully
  //         non-null if no package.json found or version in it is invalid
  //       version
  //         new version string, undefined on error
  //
  if (typeof callback !== 'function') {
    if (typeof opts !== 'function') {
      throw new Error('Unexpected callback argument')
    } else {
      callback = opts
      opts = {}
    }
  }

  exports.dry(targetPath, opts, (err, result) => {
    if (err) {
      return callback(err)
    }

    const absTarget = result.absoluteTargetPath
    const absTargetDir = path.dirname(absTarget)
    const content = result.generatedContent
    const version = result.version

    // Ensure directory exists before writing file
    fs.mkdir(absTargetDir, { recursive: true }, errp => {
      if (errp) {
        return callback(errp)
      }

      fs.writeFile(absTarget, content, 'utf8', errw => {
        if (errw) {
          return callback(errw)
        }
        return callback(null, version)
      })
    })
  })
}
